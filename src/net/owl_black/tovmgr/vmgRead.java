package net.owl_black.tovmgr;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;
import java.util.*;

/**
 * vmgRead class allows you to process all SMS files, extract informations to put them into a SMS database.
 * 
 * @author Louisbob 
 * @version 26/06/2012 - v0.3
 */
public class vmgRead implements Cloneable
{  
   //Global variables
   private Boolean isInbox = false;              //Indicate if the message is in Inbox or in Outbox
   private static ArrayList<mySms> staticSmsDB; //Static database, need to be erased by the eraseDB() method
   //Variables that store the name line type to detect into the file
   String detectName = "N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;";
   String detectText = "TEXT;ENCODING=QUOTED-PRINTABLE:";
   String detectText2 = "TEXT:";
   String detectText3 = "TEXT;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:";

    /**
     * Constructors for objects of class vmgRead
     */
    public vmgRead() {
         staticSmsDB = new ArrayList<mySms>();
    }
    
    /**
     * As the static smsDB of this object is private & static, this method reset the database.
     * 
     * @return     void
     */
    public void eraseDB() {
        staticSmsDB = null;
        staticSmsDB = new ArrayList<mySms>();
    }
    
    /** This method open a File object array type (generated by an open window), and return the result into a FileReader array type. 
     * 
     * @param  fileArray   Array that contains all the files to open
     * @return     FileReader array
     */
    public FileReader[] openFileArray(File[] fileArray) {
        
        //We create an array of FileReader
        FileReader[] fR = new FileReader[fileArray.length];//fileArray.length
        
        for(int j=0; j < fileArray.length; j++){
            try{
            fR[j] = new FileReader(fileArray[j] );}
            catch (FileNotFoundException ex){
                System.out.println("Error File Not Found!");
                ex.printStackTrace();
            }
        }
        
        return fR;
    }
    
    /** Totally process opening and analysing files from File type array
     * 
     * @param  vmgFiles   Array that contains all files that have already been opened
     * @param  box   Specify if sms are in Inbox (1) or Outbox (2)
     * @return     smsDB    ArrayList of all the SMS contained in the database
     */
    public void processArrayFile(File[] fileArray, int box) {
        FileReader[] fR;
        if(box == 2) isInbox = false;
        else isInbox = true;
        
        fR = openFileArray(fileArray);
        readMultipleVmg(fR);
    }
    
   /** Totally process opening and analysing files from File type arraylist
     * 
     * @param  vmgFiles   Array that contains all files that have already been opened
     * @param  box   Specify if sms are in Inbox (1) or Outbox (2)
     * @return     smsDB    ArrayList of all the SMS contained in the database
     */
        public void processArrayFile(ArrayList<File> fileArrayList, int box) {
        FileReader[] fR;
        File[] in = new File[fileArrayList.size()];
        
        if(box == 2) isInbox = false;
        else isInbox = true;
        
        fileArrayList.toArray(in);
        fR = openFileArray(in);
        readMultipleVmg(fR);
    }
       
    /** Add files already opened stream (FileReader) to the SMS database.
     * 
     * @param  vmgFiles   Array that contains all files that have already been opened
     * @return     smsDB    ArrayList of all the SMS contained in the database
     */
    public ArrayList<mySms> readMultipleVmg (FileReader[] vmgFiles){
        
        for(int j=0; j< vmgFiles.length; j++){
            staticSmsDB.add( readOneVmg(vmgFiles[j]) );
        }
        
        return staticSmsDB;
    }
    
    /** Add files that have don't have an opened stream (File) to the SMS database.
     * 
     * @param  fileArray   Array that contains all files to process
     * @return     smsDB    ArrayList of all the SMS contained in the database
     */
    public ArrayList<mySms> readMultipleVmg (File[] fileArray){
        
        FileReader[] vmgFiles = this.openFileArray(fileArray);
        
        for(int j=0; j< vmgFiles.length; j++){
            staticSmsDB.add( readOneVmg(vmgFiles[j]) );
        }
        
        return staticSmsDB;
    }
    
    /** Just return the content of the static private database of this object. ITS A COPY, NO A REFERENCE TO THE DB
     * 
     * @return     smsDB    ArrayList of all the SMS contained in the database
     */
    public ArrayList<mySms> getSmsDB(){
        return new ArrayList<mySms>(staticSmsDB);
    }

    /**
     * This function analyse one file opened in a FileReader, and fill a mySms object with the correct informations
     * 
     * @param  vmgFile  An already-opened file
     * @return     A mySms object totally filled
     */
    public mySms readOneVmg(FileReader vmgFile) {
        //Environment
        LineNumberReader lineRd = null;
        String line = null;
        
        //Algo
        
        //Opening FileReader
        /*
        try {
            vmgFile = new FileReader(vmgFile);
        } 
        catch (FileNotFoundException ex){ 
            System.out.println("Error File Not Found!");
            ex.printStackTrace(); 
        }
        */
        
        //Construct the LineNumberReader object
        lineRd = new LineNumberReader(vmgFile);
        
        //If it's okay, create a new SMS class
        mySms sms = new mySms();
        
        //Loop of reading
        try {
            while ((line = lineRd.readLine()) != null) {
                
                //We analyse the content of the line, and fill informations of the object
                if ( analyseLine(line, sms) == 1) {            
                }
                
                }
        }
        catch (IOException ex) {
            System.out.println("Error during getting lines from the file.");
            ex.printStackTrace();
        }
        
        _resetBeacons();
        
        //Set if the sms has been sent or received
        if (isInbox) sms.setReceived();
        if (!isInbox) sms.setSent();
        
        return sms;
    }
    
    private void _resetBeacons(){
    	baliseMsg = false; //Indique que l'on est dans un message
        balisevCard = false; //Indique que l'on est dans les infos de contact
        balisevEnvoi = false; //Indique qu'on est dans le contenu
        getNextLine = false;
    }
    
    static Boolean baliseMsg = false; //Indique que l'on est dans un message
    static Boolean balisevCard = false; //Indique que l'on est dans les infos de contact
    static Boolean balisevEnvoi = false; //Indique qu'on est dans le contenu
    static Boolean getNextLine = false;
    static double version = 0;
    
     /**
     * analyseLine allows you to analyse a line of the VMG file, and fill the sms class that could be added
     * to a database after.
     * 
     * @param  String line  Line to analyze
     * @param  sms  The sms object you want to fill with informations
     * @return     (0)    line has been correctly analyzed - 
     *             (1)    analysed file contain a valid VMG marker
     */
    public int analyseLine(String line, mySms sms) {
    	
    	if(getNextLine){
    		if (line.charAt(line.length()-1) == '=')
            {
    			//StringBuffer buf = new StringBuffer( line.length() - 1 );
    			//buf.append( line.substring(0,line.length()-1) ).append( line.substring(line.length()) );

	            try {
	        	   sms.setText(sms.getText() + line.substring(0, line.length() - 1));
	            }catch(NullPointerException ex) {
	                System.out.println("Error during message text analyse: Text(v3) marker found, but text is empty.");
	            }
    			
                //line = line.Remove(line.Length - 1);
                getNextLine = true;
            }
    		else {
    			try {
    				sms.setText(sms.getText() + line);
    			}catch(NullPointerException ex) {
                System.out.println("Error during message text analyse: Text(v3) marker found, but text is empty.");
            }
    			getNextLine = false;
    		}
    	}
    	
    	
        //Detects the beginning of message text
                if (line.equals("BEGIN:VMSG"))
                {
                    //Return 1: a new sms object will be created
                    baliseMsg = true;
                    return 1;
                }
                    //We are in the VCARD
                    if (line.equals("BEGIN:VCARD"))
                    {
                        balisevCard = true;
                    }

                    //We leave the VCARD
                    if (line.equals("END:VCARD"))
                    {
                        balisevCard = false;
                    }
                    
                //We reach the end of the file
                if (line.equals("END:VMSG"))
                {
                    baliseMsg = false;
                }

                //We are in the content of the message
                if (line.equals("BEGIN:VENV"))
                {
                    balisevEnvoi = true;
                }

                //We are out of the message marker
                if (line.equals("END:VENV"))
                {
                    balisevEnvoi = false;
                }
                
                //We are getting the version of the file
                if(line.indexOf("VERSION") != -1) {
                    
                    if( baliseMsg && !balisevCard ) {
                    String[] words = line.split(":");
                    
                    try {
                            version = Double.parseDouble(words[1]);
                        }catch(Exception ex) {
                            System.out.println("Error during version parsing");
                        }
                        
                    }
                }

                //If we are in the vcard: we get informations of it.
                if ((balisevCard == true) && (baliseMsg == true))
                {
                    //We look for the name of the sender
                    if ( line.indexOf(detectName) != -1 )
                    {
                        String[] words = line.split(";");
                        sms.setSenderName( words[words.length - 1] );
                    }

                    //We check if the line contains phone numbers
                    if (line.indexOf("TEL") != -1)
                    {
                        //If we find the word TEL, we split this line to extract numbers
                        String[] words = line.split(";");
                        
                        //We test each "word". If a word contain ':' character, it shows that there is a phone number
                        for(int j=0; j < words.length; j++) {
                            if( words[j].indexOf(":") != -1) {
                                //In this case, we split the section concerned, and copy the last number.
                                String[] phoneNum = words[j].split(":");
                                sms.setPhoneNum(phoneNum[phoneNum.length - 1]);
                            }
                        }
                    }
                }

                //If we are in the content of the message, it gets date, time and text.
                if ((balisevEnvoi == true) && (baliseMsg == true))
                {
                    //Checks if the line contain the Date
                    if (line.indexOf("Date:") != -1)
                    {
                        //We delete all non-alphanumeric characters
                        line = safeChar(line);
                        
                        String[] date = line.split(":");
                        //Each information are splited with dots.
                        date = date[1].split("\\.");

                        try {
                            sms.setYear( Integer.parseInt(date[0]) );
                            sms.setMonth( Integer.parseInt(date[1]) );
                            sms.setDay( Integer.parseInt(date[2]) );
                            sms.setHour( Integer.parseInt(date[3]) );
                            sms.setMin( Integer.parseInt(date[4]) );
                            sms.setSec( Integer.parseInt(date[5]) );
                        }catch(Exception ex) {
                            //It's maybe a bad formatting from the date. Lets try the second technic
                            String[] date2 = line.split(" ");
                            String timeTemp = date2[1];
                            date2 = date2[0].split(":");
                            date2 = date2[1].split("\\.");
                            String[] time = timeTemp.split(":");
                            
                            try {
                            sms.setYear( Integer.parseInt(date2[2]) );
                            sms.setMonth( Integer.parseInt(date2[1]) );
                            sms.setDay( Integer.parseInt(date2[0]) );
                            sms.setHour( Integer.parseInt(time[0]) );
                            sms.setMin( Integer.parseInt(time[1]) );
                            sms.setSec( Integer.parseInt(time[2]) );
                            }
                            catch(Exception ex2) {
                                System.out.println("Error during parsing of the date");
                            }
                        }
                    }

                    //Detects if line contain message text
	                    if (line.indexOf(detectText) != -1)
	                    {
	                       try {
	                            sms.setText(line.replace(detectText,""));
	                        }catch(NullPointerException ex) {
	                            System.out.println("Error during message text analyse: Text marker found, but text is empty.");
	                        }
	                    }
                    else
                    	if (line.indexOf(detectText3) != -1)
                        {
                    		if (line.charAt(line.length()-1) == '=')
                            {
                    			line = line.substring(0, line.length() - 1);
                                getNextLine = true;
                            }
                    		else
                    		getNextLine = false;
                    		
                           try {
                                sms.setText(line.replace(detectText3,""));
                            }catch(NullPointerException ex) {
                                System.out.println("Error during message text analyse: Text(v2) marker found, but text is empty.");
                            }
                        }
                    else
	                    if (line.indexOf(detectText2) != -1)
	                    {
	                       try {
	                            sms.setText(line.replace(detectText2,""));
	                        }catch(NullPointerException ex) {
	                            System.out.println("Error during message text analyse: Text(v2) marker found, but text is empty.");
	                        }
	                    }
                }
        
        //All right dude, we can leave now!
        return 0;
    }
    
    /**
     * Method that delete all non alphanumerical of a String
     * 
     * @param  String input: string to clean
     * @return String: return the cleaned string
     */
    public static String safeChar(String input)
    {
        char[] allowed = "0123456789.: ".toCharArray();
        char[] charArray = input.toString().toCharArray();
        StringBuilder result = new StringBuilder();
        for (char c : charArray)
        {
            for (char a : allowed)
            {
                if(c==a) result.append(a);
            }
        }
        return result.toString();
    }
    

}
